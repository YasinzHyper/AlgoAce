from .base import DSAAgent
from tools import RoadmapTool, ProblemRecommendationTool, FeedbackTool, ExplanationTool
from langchain.agents import Agent
from typing import Dict, List, Optional
import pandas as pd

class RoadmapAgent(DSAAgent):
    def __init__(self):
        super().__init__(
            name="Roadmap Expert",
            role="DSA Learning Path Specialist",
            goal="Create personalized DSA learning roadmaps based on user goals, time constraints, and knowledge level.",
            backstory="Expert in structuring interview preparation and DSA learning journeys with a focus on user-specific constraints.",
            tools=[RoadmapTool()]
        )

class ProblemRecommenderAgent(Agent):
    def __init__(self):
        super().__init__()
        self.name = "Problem Recommender"
        self.description = "Recommends problems based on topics and difficulty"

    async def recommend_problems(self,
                               topics: List[str],
                               difficulty_levels: List[str],
                               companies: Optional[List[str]] = None) -> List[Dict]:
        """
        Recommend problems based on topics, difficulty levels, and optionally companies
        """
        try:
            # Load LeetCode dataset
            # This would be implemented based on your data storage
            problems_df = pd.read_csv('path_to_leetcode_dataset.csv')

            # Filter problems based on criteria
            filtered_problems = problems_df[
                (problems_df['difficulty'].isin(difficulty_levels)) &
                (problems_df['related_topics'].apply(lambda x: any(topic in x for topic in topics)))
            ]

            if companies:
                filtered_problems = filtered_problems[
                    filtered_problems['companies'].apply(lambda x: any(company in x for company in companies))
                ]

            # Sort by acceptance rate and frequency
            filtered_problems = filtered_problems.sort_values(
                by=['acceptance_rate', 'frequency'],
                ascending=[False, False]
            )

            # Convert to list of dictionaries
            recommendations = filtered_problems.head(10).to_dict('records')

            return recommendations
        except Exception as e:
            print(f"Error recommending problems: {str(e)}")
            return []

class FeedbackAgent(DSAAgent):
    def __init__(self):
        super().__init__(
            name="Progress Analyst",
            role="Learning Progress Specialist",
            goal="Analyze user progress against their roadmap and provide actionable feedback.",
            backstory="Expert in learning analytics and performance improvement strategies.",
            tools=[FeedbackTool()]
        )

class ExplanationAgent(Agent):
    def __init__(self):
        super().__init__()
        self.name = "Problem Explainer"
        self.description = "Provides explanations and hints for problems"

    async def explain_problem(self,
                            problem_id: str,
                            question: str) -> str:
        """
        Provide explanation or answer to a question about a problem
        """
        try:
            # Load problem details
            # This would be implemented based on your data storage
            problem_df = pd.read_csv('path_to_leetcode_dataset.csv')
            problem = problem_df[problem_df['id'] == problem_id].iloc[0]

            # Generate explanation using the question and problem details
            # This would be implemented using your preferred LLM
            explanation = f"""
            Based on your question about {problem['title']}:
            
            {question}
            
            Here's an explanation:
            [This would be generated by your LLM based on the problem details and question]
            """

            return explanation
        except Exception as e:
            print(f"Error explaining problem: {str(e)}")
            return "Sorry, I couldn't generate an explanation at this time."